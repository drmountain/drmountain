<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DR.MOUNTAIN: HOLD THE DATE: 26/10/2024 @TRONDHEIM</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: rgb(206,161,104);
            overflow: hidden; /* Prevent scrolling */
            background: url('bg.png') no-repeat center center fixed;
            background-size: cover;
        }
        canvas {
            border: 0px solid pink;
        }
        .spinning-text {
    position: absolute;
    font-size: 2.5em;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    color: #0ff;
    text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px rgb(255, 0, 183), 0 0 80px #0ff;
    text-align: center;
    animation: blink 3s infinite, pulse 5s infinite, spin 10s linear infinite;
}

@keyframes blink {
    0%, 100% { color: #0ff; }
    50% { color: #f00; } /* You can change the second color as needed */
}

@keyframes pulse {
    0%, 100% { text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px rgb(255, 0, 183), 0 0 80px #0ff; }
    50% { text-shadow: 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff, 0 0 50px rgb(255, 0, 183), 0 0 100px #ff00ff; }
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

        .thumbs-up-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .thumbs-up-button {
            font-size: 2em;
            cursor: pointer;
            background: none;
            border: none;
            color: rgb(255, 0, 195);
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px rgb(255, 0, 183), 0 0 80px #0ff;
        }
        .thumbs-up-count {
            font-size: 2em;
            margin-left: 10px;
            color: rgb(255, 0, 195);
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px rgb(255, 0, 183), 0 0 80px #0ff;
        }
        .save-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1em;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin-left: 10px;
            color: rgb(255, 0, 195);
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px rgb(255, 0, 183), 0 0 80px #0ff;
        }
    </style>
</head>
<body>
    <canvas id="pongCanvas"></canvas>
    <div class="spinning-text">HOLD THE DATE <br> üéâ SATURDAY üéâ <br> 26.10.2024<br>TRONDHEIM</div>
    <div class="thumbs-up-container">
        <button class="thumbs-up-button" onclick="incrementThumbsUp()"> √Ü kj√¶m p√• f√¶st ja! üëç</button>
        <div class="thumbs-up-count" id="thumbsUpCount">33</div>
    </div>
    <div class="save-counter" id="saveCounter">Left Saves: 0 | Right Saves: 0</div>

    <script>
     
    const canvas = document.getElementById("pongCanvas");
    const ctx = canvas.getContext("2d");

    // Resize canvas to fit the screen
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Ball properties
    let ball = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 10,
        speed: canvas.width / 2.5, // Ball travels across the canvas in 2.5 seconds
        dx: 1, // Direction on the x-axis (+1 or -1)
        dy: 1, // Direction on the y-axis (+1 or -1)
    };

    // Player paddle properties
    const paddleWidth = 20;
    const paddleHeight = 100;
    let leftPaddleY = (canvas.height - paddleHeight) / 2;
    let rightPaddleY = (canvas.height - paddleHeight) / 2;

    // Save counters
    let leftSaves = 0;
    let rightSaves = 0;

    // AI paddle image (right player)
    const aiPaddleImg = new Image();
    aiPaddleImg.src = 'kjerstiberg.png'; // Replace with the path to your image

    // Mouse and touch movement controls the left paddle
    function moveLeftPaddle(y) {
        leftPaddleY = y - paddleHeight / 2;
    }

    canvas.addEventListener("mousemove", function(event) {
        moveLeftPaddle(event.clientY);
    });

    canvas.addEventListener("touchmove", function(event) {
        const touch = event.touches[0];
        moveLeftPaddle(touch.clientY);
    });

    // Function to draw paddles and ball
    function drawPaddle(x, y, width, height) {
        ctx.fillStyle = "pink";
        ctx.fillRect(x, y, width, height);
    }

    function drawBall() {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = "pink";
        ctx.fill();
        ctx.closePath();
    }

    function drawAiPaddle(x, y) {
        const aiPaddleSize = paddleHeight; // Make the AI paddle square
        ctx.drawImage(aiPaddleImg, x, y, aiPaddleSize, aiPaddleSize);
    }

    // Update the game state with time-based velocity
    let lastTime = performance.now();

    function update() {
        const currentTime = performance.now();
        const deltaTime = (currentTime - lastTime) / 1000; // Time in seconds since the last frame

        // Move the ball based on time
        ball.x += ball.speed * ball.dx * deltaTime;
        ball.y += ball.speed * ball.dy * deltaTime;

        // Ball collision with top and bottom walls
        if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
            ball.dy = -ball.dy;
        }

        // Ball collision with left paddle (player-controlled)
        if (ball.x - ball.radius < paddleWidth && ball.y > leftPaddleY && ball.y < leftPaddleY + paddleHeight) {
            ball.dx = -ball.dx;
            leftSaves++;
            updateSaveCounter();
        }

        // AI paddle (right side) always follows the ball
        rightPaddleY = ball.y - paddleHeight / 2;

        // Ball collision with right paddle (AI)
        const aiPaddleSize = paddleHeight;
        if (ball.x + ball.radius > canvas.width - aiPaddleSize && ball.y > rightPaddleY && ball.y < rightPaddleY + aiPaddleSize) {
            ball.dx = -ball.dx;
            rightSaves++;
            updateSaveCounter();
        }

        // Ball out of bounds (reset to center)
        if (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.dx = -ball.dx;
        }

        lastTime = currentTime; // Update time for the next frame
    }

    // Update the save counter display
    function updateSaveCounter() {
        document.getElementById('saveCounter').innerText = `Left Saves: ${leftSaves} | Right Saves: ${rightSaves}`;
    }

    // Main game loop
    function gameLoop() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw paddles and ball
        drawPaddle(0, leftPaddleY, paddleWidth, paddleHeight); // Left paddle (player-controlled)
        drawAiPaddle(canvas.width - paddleHeight, rightPaddleY); // Right paddle (AI), square shape
        drawBall();

        // Update game state
        update();

        // Loop the game
        requestAnimationFrame(gameLoop);
    }

    // Start the game loop when the AI image has loaded
    aiPaddleImg.onload = function() {
        gameLoop();
    };

        // Thumbs up counter
        let thumbsUpCount = 33;
        function incrementThumbsUp() {
            thumbsUpCount++;
            document.getElementById("thumbsUpCount").innerText = thumbsUpCount;
        }
    </script>
</body>
</html>
